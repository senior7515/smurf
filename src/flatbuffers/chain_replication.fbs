// Copyright 2017 Alexander Gallego
//
include "wal.fbs";

namespace smf.chains;

// todo! wrap all types
// we need a transaction manager that moves the pointer along
// once all chain replicas have acknowledge write.

table chain_put {
  chain:       [uint];
  chain_index: uint = 0;
  /// brief each put is actually a put of a single: (Topic,Parition) tuple.
  /// so you can produce many key=value items per topic,partition
  /// ... in essence is an array of arrays. The first array is the topic, partition
  /// grouping, and the second is just a set of key=value pairs.
  ///
  puts:        [smf.wal.tx_put_request];
}

rpc_service chain_replication {

  /// TODO(agallego) right now the wal write part is sophisticated
  /// we need to introduce a session manager for the reads and the rebalancing
  /// of topics - i.e.: what consumers get what. 
  put(chain_put): smf.wal.tx_put_reply;
  get(smf.wal.tx_get_request): smf.wal.tx_get_reply;
}
