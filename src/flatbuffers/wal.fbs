// Copyright 2017 Alexander Gallego
//
namespace smf.wal;

// TAG: alpha

enum wal_entry_compression_type:byte {
  none,
  zstd,
  lz4
}

struct wal_header {
  /// \brief, we use xxhash64 since xxhash32 is slow
  checksum:    ulong;
  size:        uint;
  version:     ubyte;
  compression: wal_entry_compression_type;
  /// Note we still have 16 bits unused
}


enum tx_put_operation:byte {
  none,
  begin,
  data,
  commit,
  abort,

  /// \brief either the end of the txn OR a full transaction that is a small payload
  /// i.e.: fits in one request
  full
}

enum tx_put_invalidation_reason:byte {
  none,
  server_connection_timeout,
  client_connection_timeout
}

enum tx_put_fragment_type:byte {
  none,
  kv,
  invalidation
}

/// \brief This is the datastructure that gets persisted on disk.
/// Please be tender while extending
/// When you extend this, please don't forget to change
/// \code
///    filesystem/wal_write_projection.cc::xform() method
/// \endcode
///
table tx_put_fragment {
  /// what should we do with this trasaction fragment
  op:           tx_put_operation = none;
  /// holds what kind of data we expect in the payload
  type:         tx_put_fragment_type = none;
  /// In seastar clients we will use a losely ticked timer which moves
  /// every 10 micros.
  /// This is needed for systems doing window aggregations, etc.
  /// expected resolution is milliseconds
  epoch_ms:     ulong = 0;

  /// The reason key=value *and* invalidations are part of the same
  /// struct is performance. every table is 12 bytes

  key:              [ubyte];
  value:            [ubyte];

  invalidation_reason: tx_put_invalidation_reason = none;
  /// iff this->op == tx_put_operation::abort
  /// use to write an abort, for a specific offset
  /// This is the offset from the tx_put_reply.
  invalidation_offset: ulong = 0;

}
table tx_put_binary_fragment {
  /// \brief this is *not* in a format that is friendly
  /// to flatbuffers for performance reasons.
  /// It is a format friendly to the disk
  ///
  /// [ header ][ payload ]
  ///
  ///
  /// [ header ] is 9 bytes
  /// [ 4byte size of payload, 4byte hash, 1byte compression ]
  ///
  ///
  /// [ payload ] is a byte array representation of a tx_put_fragment
  ///
  /// Note: When constructing the payload, make sure you set
  /// builder.ForceDefaults(true);
  ///
  /// on flatbuffers, since the defaults might change over time, breaking
  /// the reader's expectation
  ///
  data: [ubyte];
}
table tx_put_partition_tuple {
  partition:   uint (key);
  txs: [tx_put_binary_fragment];
}

/// brief - stores `puts` transactionally
table tx_put_request {
  topic:   string;
  data:    [tx_put_partition_tuple];
}

table tx_put_reply_partition_tuple {
  topic:       string;
  partition:   uint (key);
  /// \brief the committed offset into the WAL
  ///  clients can monitor how much disk was consumed by the puts
  ///  and we need this for cache eviction and management.
  start_offset: ulong;
  end_offset:   ulong;

}
table tx_put_reply {
  offsets: [tx_put_reply_partition_tuple];
}


table tx_get_request {
  topic:      string;
  partition:  uint;
  offset:     ulong;
  /// (1 << 31) - 1 Max payload payload by flatbuffers 2GB-1
  /// we decrease it by 100 bytes so we can stuff headers in there
  /// plus plenty of room for growth
  ///
  /// >>> (2**31)-100
  /// 2147483548
  ///
  /// default is 2MB -> 2048 * 1024
  max_bytes:  uint = 2097152;
}

/// \brief the broker might have decided to compress the tx_put_fragment.
/// 
table tx_get_fragment {
  hdr:             wal_header;
  /// \brief nothing more than a byte array of a possibly compressed
  /// tx_put_fragment
  fragment:        [ubyte]; 
}
enum wal_read_errno:byte {
  /// \brief - we chillin
  none,

  /// \brief the offset does not exist
  invalid_offset,

  /// \brief header for WAL entry is corrupted
  invalid_header,

  /// \brief invalid checksum for the payload
  missmatching_payload_checksum,

  /// \brief the header of the entry says the payload is of size
  /// and that size does not match with the actual data read
  /// from the disk
  missmatching_header_payload_size,
}
table tx_get_reply {
  next_offset: ulong;
  gets:        [tx_get_fragment];
  error:       wal_read_errno = none;
}

table wal_watermark {
  topic:          string;
  partition:      uint;
  low_watermark:  ulong;
  high_watermark: ulong;
}