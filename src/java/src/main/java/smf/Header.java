// automatically generated by the FlatBuffers compiler, do not modify

package smf;

import java.nio.*;
import java.lang.*;
import java.util.*;
import com.google.flatbuffers.*;

@SuppressWarnings("unused")
/**
 * \brief: header parsed by rpc engine
 * must be sizeof()'able
 * that is, must be a struct in fbs language
 *
 * layout
 * [ 8bits(compression) + 8bits(bitflags) + 16bits(session) + 32bits(size) + 32bits(checksum) + 32bits(meta) ]
 * total = 128bits == 16bytes
 *
 */
public final class Header extends Struct {
  public void __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; }
  public Header __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte compression() { return bb.get(bb_pos + 0); }
  public byte bitflags() { return bb.get(bb_pos + 1); }
  /**
   * 16 bits for storing the actual session id.
   * used for streaming client and slot allocation
   */
  public int session() { return bb.getShort(bb_pos + 2) & 0xFFFF; }
  /**
   * size of the next payload
   */
  public long size() { return (long)bb.getInt(bb_pos + 4) & 0xFFFFFFFFL; }
  /**
   * currently we use xxhash32
   */
  public long checksum() { return (long)bb.getInt(bb_pos + 8) & 0xFFFFFFFFL; }
  /**
   * \brief used for sending and receiving, read carefully.
   *
   * Receiving:
   *
   * Uses the same as HTTP status - on the receiving end
   * We don't want to pay the cost of parsing a header
   * On every response as does HTTP. std::to_string and std::stol()
   * are needlesly expensive
   *
   * Sending:
   *
   * Used with the xor hash of Service::ID() ^ Service::Method::ID()
   * This is how the server multiplexer figures out what function pointer
   * to call
   *
   */
  public long meta() { return (long)bb.getInt(bb_pos + 12) & 0xFFFFFFFFL; }

  public static int createHeader(FlatBufferBuilder builder, byte compression, byte bitflags, int session, long size, long checksum, long meta) {
    builder.prep(4, 16);
    builder.putInt((int)meta);
    builder.putInt((int)checksum);
    builder.putInt((int)size);
    builder.putShort((short)session);
    builder.putByte(bitflags);
    builder.putByte(compression);
    return builder.offset();
  }
}

