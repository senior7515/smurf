// Copyright (c) 2016 Alexander Gallego. All rights reserved.
//
#include "smfc/cpp_generator.h"

#include <map>
#include <sstream>

#include <gflags/gflags.h>
#include <glog/logging.h>

#include "smfc/smf_file.h"
#include "smfc/smf_printer.h"

DEFINE_string(services_namespace, "", "puts the service into a namespace");
DEFINE_string(search_path, "", "prefix to any smf generator include");
DEFINE_bool(use_system_headers, true, "use #include<>, vs #include\"\"");

namespace smf_gen {
namespace {

template <class T>
std::string
as_string(T x) {
  std::ostringstream out;
  out << x;
  return out.str();
}

std::string
file_name_identifier(const std::string &filename) {
  std::string result;
  for (unsigned i = 0; i < filename.size(); i++) {
    char c = filename[i];
    if (isalnum(c)) {
      result.push_back(toupper(c));
    } else if (c == '_') {
      result.push_back(c);
    } else {
      static char hex[] = "0123456789abcdef";
      result.push_back('_');
      result.push_back(hex[(c >> 4) & 0xf]);
      result.push_back(hex[c & 0xf]);
    }
  }
  return result;
}
}  // namespace

template <class T, size_t N>
T *
array_end(T (&array)[N]) {
  return array + N;
}


inline bool
is_camel_case(const std::string &s) {
  return std::find_if(s.begin(), s.end(), ::isupper) != s.end();
}
inline std::string
lower_vec(const std::vector<std::string> &vec) {
  std::stringstream ss;
  for (auto &x : vec) { ss << x; }
  auto retval = ss.str();
  for (auto i = 0u; i < retval.length(); ++i) {
    if (std::isalnum(retval[i])) { retval[i] = std::tolower(retval[i]); }
  }
  return retval;
}
inline std::string
proper_postfix_token(std::string s, std::string postfix) {
  CHECK(!s.empty() || !postfix.empty()) << "Can't compute postfix token";
  if (is_camel_case(s)) {
    s[0]       = std::toupper(s[0]);
    postfix[0] = std::toupper(postfix[0]);
    return s + postfix;
  }
  return lower_vec({s, std::string("_"), postfix});
}
inline std::string
proper_prefix_token(std::string prefix, std::string s) {
  CHECK(!s.empty() || !prefix.empty()) << "Can't compute postfix token";
  if (is_camel_case(s)) {
    s[0]      = toupper(s[0]);
    prefix[0] = toupper(prefix[0]);
    return prefix + s;
  }
  return lower_vec({prefix, std::string("_"), s});
}


void
print_includes(smf_printer *printer, const std::vector<std::string> &headers) {
  VLOG(1) << "print_includes";
  std::map<std::string, std::string> vars;
  vars["l"] = FLAGS_use_system_headers ? '<' : '"';
  vars["r"] = FLAGS_use_system_headers ? '>' : '"';
  if (!FLAGS_search_path.empty()) {
    vars["l"] += FLAGS_search_path;
    if (FLAGS_search_path.back() != '/') { vars["l"] += '/'; }
  }
  for (auto i = headers.begin(); i != headers.end(); i++) {
    vars["h"] = *i;
    printer->print(vars, "#include $l$$h$$r$\n");
  }
}

std::string
get_header_prologue(smf_file *file) {
  VLOG(1) << "get_header_prologue";
  std::string                        output;
  auto                               printer = file->create_printer(&output);
  std::map<std::string, std::string> vars;

  // FIXME - weird ._generated.h
  vars["filename"] = file->filename();
  vars["filename_identifier"] =
    file_name_identifier(file->filename_without_path());
  vars["filename_base"]      = file->filename_without_ext();
  vars["message_header_ext"] = file->message_header_ext();

  printer->print("// Generated by the smf_gen.\n");
  printer->print("// Any local changes WILL BE LOST.\n");
  printer->print(vars, "// source: $filename$\n");
  printer->print("#pragma once\n");
  printer->print(vars, "#ifndef SMF_$filename_identifier$_INCLUDED\n");
  printer->print(vars, "#define SMF_$filename_identifier$_INCLUDED\n");
  printer->print(vars, "#include \"$filename_base$$message_header_ext$\"\n\n");
  return output;
}

std::string
get_header_includes(smf_file *file) {
  VLOG(1) << "get_header_includes";
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto                               printer = file->create_printer(&output);
    std::map<std::string, std::string> vars;

    static const char *headers_strs[] = {"core/sstring.hh",
                                         "experimental/optional",
                                         "smf/rpc_service.h",
                                         "smf/rpc_client.h",
                                         "smf/rpc_recv_typed_context.h",
                                         "smf/rpc_typed_envelope.h",
                                         "smf/log.h"};

    std::vector<std::string> headers(headers_strs, array_end(headers_strs));
    print_includes(printer.get(), headers);
    printer->print("\n");

    if (!file->package().empty()) {
      std::vector<std::string> parts = file->package_parts();

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer->print(vars, "namespace $part$ {\n");
      }
      printer->print("\n");
    }
  }
  return output;
}


void
print_header_service_ctor_dtor(smf_printer *      printer,
                               const smf_service *service) {
  VLOG(1) << "print_header_service_ctor_dtor for service: " << service->name();
  std::map<std::string, std::string> vars;

  vars["Service"] = service->name();
  printer->print(vars, "~$Service$() = default;\n");
  printer->print(vars, "$Service$() {\n");
  printer->indent();

  for (int i = 0; i < service->method_count(); ++i) {
    auto method           = service->method(i);
    vars["MethodName"]    = method->name();
    vars["RawMethodName"] = proper_prefix_token("raw", method->name());
    vars["InType"]        = method->input_type_name();
    vars["OutType"]       = method->output_type_name();
    vars["MethodId"]      = std::to_string(method->method_id());
    printer->print("handles_.emplace_back(\n");
    printer->indent();
    printer->print(vars, "\"$MethodName$\", $MethodId$,\n");
    printer->print("[this](smf::rpc_recv_context c) -> "
                   "seastar::future<smf::rpc_envelope> {\n");
    printer->indent();
    printer->print("// Session accounting\n"
                   "auto session_id = c.session();\n");
    printer->print(vars, "return $RawMethodName$(std::move(c)).then("
                         "[session_id](auto e){\n");
    printer->indent();
    printer->print(
      "e.letter.header.mutate_session(session_id);\n"
      "return seastar::make_ready_future<smf::rpc_envelope>(std::move(e));\n");
    printer->outdent();
    printer->print("});\n");
    printer->outdent();
    printer->outdent();
    printer->print("});\n");
  }
  printer->outdent();
  printer->print("}\n");
}
void
print_header_service_handle_request_id(smf_printer *      printer,
                                       const smf_service *service) {
  printer->print("virtual smf::rpc_service_method_handle *\n"
                 "method_for_request_id(uint32_t idx) override final {\n");
  printer->indent();
  printer->print("switch(idx){\n");
  printer->indent();
  for (int i = 0; i < service->method_count(); ++i) {
    std::map<std::string, std::string> vars;
    auto                               method = service->method(i);
    vars["ServiceID"] = std::to_string(method->service_id());
    vars["MethodId"]  = std::to_string(method->method_id());
    vars["VectorIdx"] = std::to_string(i);
    printer->print(
      vars,
      "case ($ServiceID$ ^ $MethodId$): return &handles_[$VectorIdx$];\n");
  }
  printer->print("default: return nullptr;\n");
  printer->outdent();
  printer->print("}\n");
  printer->outdent();
  printer->print("}\n");
}
void
print_header_service_handles(smf_printer *printer) {
  printer->print("virtual const std::vector<smf::rpc_service_method_handle> &\n"
                 "methods() override final {\n");
  printer->indent();
  printer->print("return handles_;\n");
  printer->outdent();
  printer->print("}\n");
}
void
print_header_service_method(smf_printer *printer, const smf_method *method) {
  VLOG(1) << "print_header_service_method: " << method->name();

  std::map<std::string, std::string> vars;
  vars["RawMethodName"] = proper_prefix_token("raw", method->name());
  vars["MethodName"]    = method->name();
  vars["MethodId"]      = std::to_string(method->method_id());
  vars["InType"]        = method->input_type_name();
  vars["OutType"]       = method->output_type_name();
  printer->print(vars, "inline virtual\n"
                       "seastar::future<smf::rpc_typed_envelope<$OutType$>>\n");
  printer->print(
    vars, "$MethodName$(smf::rpc_recv_typed_context<$InType$> &&rec) {\n");
  printer->indent();
  printer->print(
    vars, "using out_type = $OutType$;\n"
          "using env_t = smf::rpc_typed_envelope<out_type>;\n"
          "env_t data;\n"
          "//\n"
          "//\n"
          "// USER SHOULD OVERRIDE THIS METHOD.\n"
          "//\n"
          "//\n"
          "// Helpful for clients to set the status.\n"
          "// Typically follows HTTP style. Not imposed by smf whatsoever.\n"
          "// i.e. 501 == Method not implemented\n"
          "data.envelope.set_status(501);\n"
          "return seastar::make_ready_future<env_t>(std::move(data));\n");
  printer->outdent();
  printer->print("}\n");

  // RAW

  printer->print(vars, "inline virtual\n"
                       "seastar::future<smf::rpc_envelope>\n");
  printer->print(vars, "$RawMethodName$(smf::rpc_recv_context &&c) {\n");
  printer->indent();
  printer->print(
    vars, "using inner_t = $InType$;\n"
          "using input_t = smf::rpc_recv_typed_context<inner_t>;\n"
          "return $MethodName$(input_t(std::move(c))).then([this](auto x){\n");
  printer->indent();
  printer->print("return "
                 "seastar::make_ready_future<smf::rpc_envelope>(x.serialize_"
                 "data());\n");
  printer->outdent();
  printer->print("});\n");
  printer->outdent();
  printer->print("}\n");
}

void
print_header_service(smf_printer *printer, const smf_service *service) {
  VLOG(1) << "print_header_service: " << service->name();
  std::map<std::string, std::string> vars{};
  vars["Service"]   = service->name();
  vars["ServiceID"] = std::to_string(service->service_id());

  printer->print(vars, "class $Service$: public smf::rpc_service {\n");
  printer->print(" private:\n");
  printer->print("  std::vector<smf::rpc_service_method_handle> handles_;\n");
  printer->print(" public:\n");
  printer->indent();
  print_header_service_ctor_dtor(printer, service);

  // print the overrides for smf
  printer->print("virtual const char *\n"
                 "service_name() const override final {\n");
  printer->indent();
  printer->print(vars, "return \"$Service$\";\n");
  printer->outdent();
  printer->print("}\n");
  printer->print("virtual uint32_t\n"
                 "service_id() const override final {\n");
  printer->indent();
  printer->print(vars, "return $ServiceID$;\n");
  printer->outdent();
  printer->print("}\n");

  print_header_service_handles(printer);
  print_header_service_handle_request_id(printer, service);

  for (int i = 0; i < service->method_count(); ++i) {
    print_header_service_method(printer, service->method(i).get());
  }

  printer->outdent();
  printer->print(vars, "}; // end of service: $Service$\n");
}


void
print_header_client_method(smf_printer *printer, const smf_method *method) {
  std::map<std::string, std::string> vars;
  vars["RawMethodName"] = proper_prefix_token("raw", method->name());
  vars["MethodName"]    = method->name();
  vars["MethodID"]      = std::to_string(method->method_id());
  vars["ServiceID"]     = std::to_string(method->service_id());
  vars["ServiceName"]   = method->service_name();
  vars["InType"]        = method->input_type_name();
  vars["OutType"]       = method->output_type_name();

  printer->print(vars,
                 "inline virtual\n"
                 "seastar::future<smf::rpc_recv_typed_context<$OutType$>>\n"
                 "$MethodName$(smf::rpc_envelope e) {\n");
  printer->indent();
  printer->print(vars,
                 "/// RequestID: $ServiceID$ ^ $MethodID$\n"
                 "/// ServiceID: $ServiceID$ == crc32(\"$ServiceName$\")\n"
                 "/// MethodID:  $MethodID$ == crc32(\"$MethodName$\")\n"
                 "e.set_request_id($ServiceID$ ^ $MethodID$);\n"
                 "return send<$OutType$>(std::move(e));\n");
  printer->outdent();
  printer->print("}\n");

  // RAW
  printer->print(
    vars,
    "inline virtual\n"
    "seastar::future<std::experimental::optional<smf::rpc_recv_context>>\n"
    "$RawMethodName$(smf::rpc_envelope e) {\n");
  printer->indent();
  printer->print(vars,
                 "/// RequestID: $ServiceID$ ^ $MethodID$\n"
                 "/// ServiceID: $ServiceID$ == crc32(\"$ServiceName$\")\n"
                 "/// MethodID:  $MethodID$ == crc32(\"$MethodName$\")\n"
                 "e.set_request_id($ServiceID$ ^ $MethodID$);\n"
                 "return raw_send(std::move(e));\n");
  printer->outdent();
  printer->print("}\n");
}

void
print_header_client(smf_printer *printer, const smf_service *service) {
  // print the client rpc code
  VLOG(1) << "print_header_client for service: " << service->name();
  std::map<std::string, std::string> vars{};
  vars["ClientName"] = proper_postfix_token(service->name(), "client");
  vars["ServiceID"]  = std::to_string(service->service_id());

  printer->print(vars, "class $ClientName$:\n");
  printer->indent();
  printer->print("public smf::rpc_client,\n");
  printer->print(vars,
                 "public seastar::enable_shared_from_this<$ClientName$> {\n");
  printer->outdent();
  printer->print("\n");
  printer->indent();
  printer->print("private:\n");
  printer->indent();
  // print ctor
  printer->print(vars, "$ClientName$(seastar::ipv4_addr "
                       "server_addr)\n:smf::rpc_client(std::move("
                       "server_addr)) {}\n");
  // print ctor2
  printer->print(vars, "$ClientName$(smf::rpc_client_opts o)"
                       "\n:smf::rpc_client(std::move(o)) {}\n");
  printer->outdent();
  printer->outdent();
  printer->print("\n");

  printer->indent();
  printer->print("public:\n");
  printer->indent();

  // print make1
  printer->print(vars, "static seastar::shared_ptr<$ClientName$>\n");
  printer->print("make_shared(seastar::ipv4_addr addr) {\n");
  printer->indent();
  printer->print(vars, "$ClientName$ c(std::move(addr));\n");
  printer->print(vars,
                 "return seastar::make_shared<$ClientName$>(std::move(c));\n");
  printer->outdent();
  printer->print("}\n");

  // print make2
  printer->print(vars, "static seastar::shared_ptr<$ClientName$>\n");
  printer->print("make_shared(smf::rpc_client_opts o) {\n");
  printer->indent();
  printer->print(vars, "$ClientName$ c(std::move(o));\n");
  printer->print(vars,
                 "return seastar::make_shared<$ClientName$>(std::move(c));\n");
  printer->outdent();
  printer->print("}\n");

  // move ctor
  printer->print(vars, "$ClientName$($ClientName$ &&o) = default;\n");

  // print ctor2
  printer->print(vars, "~$ClientName$() {}\n");

  // name
  printer->print("virtual const char *name() const final {\n");
  printer->indent();
  printer->print(vars, "return \"$ClientName$\";\n");
  printer->outdent();
  printer->print("}\n");

  // shared_form_from this method
  printer->print("virtual seastar::shared_ptr<rpc_client> "
                 "parent_shared_from_this() final {\n");
  printer->indent();
  printer->print(vars, "return shared_from_this();\n");
  printer->outdent();
  printer->print("}\n");


  for (int i = 0; i < service->method_count(); ++i) {
    print_header_client_method(printer, service->method(i).get());
  }

  printer->outdent();
  printer->print(vars, "}; // end of rpc client: $ClientName$\n");
  printer->outdent();
}

std::string
get_header_services(smf_file *file) {
  VLOG(1) << "get_header_services";

  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto                               printer = file->create_printer(&output);
    std::map<std::string, std::string> vars;
    // Package string is empty or ends with a dot. It is used to fully qualify
    // method names.
    vars["Package"] = file->package();
    if (!file->package().empty()) { vars["Package"].append("."); }

    if (!FLAGS_services_namespace.empty()) {
      vars["services_namespace"] = FLAGS_services_namespace;
      printer->print(vars, "\nnamespace $services_namespace$ {\n\n");
    }

    for (int i = 0; i < file->service_count(); ++i) {
      print_header_service(printer.get(), file->service(i).get());
      printer->print("\n");
    }

    for (int i = 0; i < file->service_count(); ++i) {
      print_header_client(printer.get(), file->service(i).get());
      printer->print("\n");
    }

    if (!FLAGS_services_namespace.empty()) {
      printer->print(vars, "}  // namespace $services_namespace$\n\n");
    }
  }
  return output;
}

std::string
get_header_epilogue(smf_file *file) {
  VLOG(1) << "get_header_epilogue";

  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto                               printer = file->create_printer(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->filename();
    vars["filename_identifier"] =
      file_name_identifier(file->filename_without_path());

    if (!file->package().empty()) {
      std::vector<std::string> parts = file->package_parts();

      for (auto part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer->print(vars, "}  // namespace $part$\n");
      }
      printer->print(vars, "\n");
    }

    printer->print(vars, "\n");
    printer->print(vars, "#endif  // SMF_$filename_identifier$_INCLUDED\n");
  }
  return output;
}


}  // namespace smf_gen
